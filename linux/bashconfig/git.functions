# Clone using worktrees
# Credit https://gabri.me/blog/git-worktrees-done-right
gclone() {
  local usage="Usage: gwt-clone <repo-url> [project-name] [branch...]"

  # Args
  local repo_url="${1:?$usage}"
  local project_name="${2:-$(basename "$repo_url" .git)}"
  shift 2 2>/dev/null || shift 1

  # Create project dir and bare clone
  mkdir -p "$project_name" && cd "$project_name" || return 1
  echo "ðŸ“¦ Cloning bare repo into $project_name..."
  git clone --bare "$repo_url" .bare || return 1

  # Magic .git file + config
  echo "gitdir: ./.bare" > .git
  git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
  git config worktree.useRelativePaths true

  echo "ðŸ”„ Fetching all branches..."
  git fetch --all --quiet

  # Default branch detection
  local default_branch
  default_branch=$(git symbolic-ref --short refs/remotes/origin/HEAD 2>/dev/null | sed 's|origin/||')
  default_branch="${default_branch:-main}"

  # Add default branch worktree first
  echo "ðŸŒ¿ Adding worktree for default branch: $default_branch"
  git worktree add "$default_branch" "$default_branch" 2>/dev/null || \
  git worktree add "$default_branch" "origin/$default_branch"

  # Add any extra branches passed as args
  for branch in "$@"; do
    if [ "$branch" != "$default_branch" ]; then
      echo "ðŸŒ¿ Adding worktree for: $branch"
      git worktree add "$branch" "$branch" 2>/dev/null || \
      git worktree add "$branch" "origin/$branch"
    fi
  done

  echo "âœ… Done! Structure:"
  ls -1
}

gswitch() {
  local branch="${1:?Usage: gswitch <branch-name> [start-point]}"
  local start="${2:-HEAD}"
  git worktree add "$branch" -b "$branch" "$start" 2>/dev/null || \
  git worktree add "$branch" "$branch"
}

# Switch the 'origin' remote URL between SSH and HTTPS formats while preserving host and path.
# Verifies access to the remote after switching and provides feedback.
git-switch-origin() {
  (
    set -euo pipefail

    # usage info
    if [[ $# -ne 1 || ( "$1" != "--ssh" && "$1" != "--https" ) ]]; then
      echo "Usage: git-switch-origin --ssh | --https" >&2
      return 1
    fi

    local TARGET="${1#--}"
    local REMOTE="origin"

    # confirm repo
    git rev-parse --git-dir >/dev/null 2>&1 || { echo "âŒ Not a git repo."; return 1; }

    # get current URL
    local CUR_URL
    CUR_URL=$(git remote get-url "$REMOTE" 2>/dev/null || true)
    [[ -z "$CUR_URL" ]] && { echo "âŒ Remote '$REMOTE' not found."; return 1; }

    # parse host + path
    local host path
    if [[ "$CUR_URL" =~ ^git@([^:]+):(.+)$ ]]; then
      host="${BASH_REMATCH[1]}"
      path="${BASH_REMATCH[2]}"
    elif [[ "$CUR_URL" =~ ^https?://([^/]+)/(.+)$ ]]; then
      host="${BASH_REMATCH[1]}"
      path="${BASH_REMATCH[2]}"
    else
      echo "âŒ Unsupported remote URL format: $CUR_URL" >&2
      return 1
    fi
    path="${path%.git}"

    # build new URL
    local NEW_URL
    if [[ "$TARGET" == "https" ]]; then
      NEW_URL="https://${host}/${path}.git"
    else
      NEW_URL="git@${host}:${path}.git"
    fi

    echo "âž¡ï¸ Switching '$REMOTE' from:"
    echo "   $CUR_URL"
    echo "   â†’ $NEW_URL"
    git remote set-url "$REMOTE" "$NEW_URL"

    # verify access
    echo "ðŸ”Ž Verifying access..."
    if git ls-remote "$REMOTE" HEAD >/dev/null 2>&1; then
      echo "âœ… Verified: able to access $REMOTE via $TARGET."
    else
      echo "âŒ Verification failed."
      if [[ "$TARGET" == "ssh" ]]; then
        echo "   â†’ Check your SSH key + org SSO authorization." >&2
      else
        echo "   â†’ Run 'gh auth setup-git' to configure HTTPS token." >&2
      fi
      return 2
    fi

    echo "âœ¨ Done."
  )
}


git-save() { (

  # NOTE
  # Snapshots record submodules as gitlinks to their current commits (not the submodulesâ€™ working trees)
  # LFS objects are just regular blobs unless theyâ€™ve been committed as LFS pointers (untracked/unstaged big files will upload as full blobs)

  # Safe options scoped to subshell
  set -e
  set -u
  set -o pipefail 2>/dev/null || true

  # Configuration (add flags later if you want)
  REMOTE="origin"
  SNAPSHOT_BRANCH="snapshot/${USER:-dev}"
  INCLUDE_IGNORED="false"
  MESSAGE="Snapshot of working tree"
  QUIET="false"
  URL_FORMAT="https"  # Options: "https" or "ssh"

  # ============================================================================
  # Core Functions
  # ============================================================================

  get_repo_context() {
    # Gathers essential repository metadata and validates we're in a git repo.
    # Sets global variables for repo name, current branch, HEAD commit, hostname,
    # and timestamp. Also changes to the repository root directory.
    git rev-parse --git-dir >/dev/null 2>&1 || { echo "âŒ Not a git repo."; exit 1; }

    TOP=$(git rev-parse --show-toplevel)
    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "DETACHED")
    PARENT_COMMIT=$(git rev-parse -q --verify HEAD 2>/dev/null || true)
    REPO_NAME=$(basename "$TOP")
    HOST=$(hostname -s 2>/dev/null || echo "host")
    TS=$(date -u +%Y%m%dT%H%M%SZ)

    cd "$TOP"
  }

  fetch_previous_snapshot_oid() {
    # Fetches the remote snapshot branch into a temporary ref to get its commit ID.
    # Uses a temp ref to avoid polluting the local branch namespace. Returns the
    # commit SHA if it exists, or empty string if this is the first snapshot.
    local snap_ref="refs/heads/${SNAPSHOT_BRANCH}"
    local tmp_ref="refs/tmp/git-save-snap-$$-$(date +%s%N)"

    # Clean in case a previous run died mid-flight
    git update-ref -d "$tmp_ref" >/dev/null 2>&1 || true

    # Fetch remote tip into our unique temp ref
    git fetch --no-tags "$REMOTE" "+${snap_ref}:${tmp_ref}" >/dev/null 2>&1 || true

    if git show-ref --verify --quiet "$tmp_ref"; then
      git rev-parse "$tmp_ref"
    else
      echo ""
    fi

    # ðŸ”¹ This is the â€œdelete temp refâ€ bit: remove the throwaway ref we just created.
    git update-ref -d "$tmp_ref" >/dev/null 2>&1 || true
  }

  build_snapshot_tree() {
    # Creates a git tree object from the current working directory using a temporary index.
    # Seeds the temp index from HEAD (helps with sparse checkouts), then adds all working
    # tree files. Returns the tree SHA. This is the core magic that snapshots your work
    # without touching your actual staging area.
    local tmp_index
    tmp_index="$(mktemp "${TMPDIR:-/tmp}/git-index.XXXXXX")"
    trap 'rm -f "${tmp_index-}"' EXIT
    export GIT_INDEX_FILE="$tmp_index"

    # Seed from HEAD if it exists (helps sparse/unborn)
    [[ -n "${PARENT_COMMIT:-}" ]] && git read-tree "$PARENT_COMMIT"

    # Add working tree
    if [[ "$INCLUDE_IGNORED" == "true" ]]; then
      git add -A -f .
    else
      git add -A .
    fi

    # Write tree (loud failure)
    local tree_id
    if ! tree_id=$(git write-tree 2>._git_save_write_tree_err); then
      echo "âŒ git write-tree failed:" >&2
      sed -n '1,120p' ._git_save_write_tree_err >&2 || true
      rm -f ._git_save_write_tree_err
      exit 1
    fi
    rm -f ._git_save_write_tree_err

    if [[ -z "$tree_id" ]]; then
      echo "âŒ Empty tree generated. Debug (temp index):" >&2
      git ls-files --stage >&2 || true
      exit 1
    fi
    echo "$tree_id"
  }

  create_snapshot_commit() {
    # Creates a commit from the given tree with two parents (when possible):
    # Parent 1: previous snapshot (enables fast-forward pushes)
    # Parent 2: current HEAD (shows provenance - what your code was based on)
    # Returns the new commit SHA.
    local tree_id="$1"
    local prev_snapshot="$2"

    local commit_msg="$MESSAGE

Repo: $REPO_NAME
When: $TS (UTC)
Host: $HOST
From branch: $CURRENT_BRANCH
Parent (HEAD): ${PARENT_COMMIT:-<none>}
Snapshot branch: $SNAPSHOT_BRANCH
Includes: working tree (untracked included$([[ "$INCLUDE_IGNORED" == "true" ]] && echo ", ignored included"))"

    # Parents: prev snapshot (for FF), then HEAD (provenance)
    local parents=()
    [[ -n "$prev_snapshot"     ]] && parents+=(-p "$prev_snapshot")
    [[ -n "${PARENT_COMMIT:-}" ]] && parents+=(-p "$PARENT_COMMIT")

    if [[ ${#parents[@]} -eq 0 ]]; then
      printf "%s\n" "$commit_msg" | git commit-tree "$tree_id"
    else
      printf "%s\n" "$commit_msg" | git commit-tree "$tree_id" "${parents[@]}"
    fi
  }

  update_local_ref() {
    # Updates the local snapshot branch ref to point to the new commit.
    # Uses update-ref with the *current local* value for atomic compare-and-swap safety.
    # This moves the branch pointer without doing a checkout.
    local new_commit="$1"
    local _prev_snapshot_ignored="$2"  # kept for compatibility with call sites
    local snap_ref="refs/heads/${SNAPSHOT_BRANCH}"

    local cur_local
    cur_local=$(git rev-parse -q --verify "$snap_ref" 2>/dev/null || true)

    if [[ -n "$cur_local" ]]; then
      git update-ref "$snap_ref" "$new_commit" "$cur_local"
    else
      git update-ref "$snap_ref" "$new_commit"
    fi
  }

  push_snapshot() {
    # Pushes the *commit SHA* to the remote branch; remote moves only if push succeeds.
    local q=()
    [[ "$QUIET" == "true" ]] && q+=(--quiet)

    local ref="refs/heads/${SNAPSHOT_BRANCH}"

    if ! git ls-remote --exit-code "$REMOTE" "$ref" >/dev/null 2>&1; then
      git push "${q[@]}" -u "$REMOTE" "${NEW_COMMIT}:${ref}"
    else
      git push "${q[@]}" "$REMOTE" "${NEW_COMMIT}:${ref}"
    fi
  }

  build_commit_url() {
    # Constructs a web-friendly URL pointing to the commit on the remote host.
    # Normalizes URLs based on URL_FORMAT setting (https or ssh).
    # For https: converts SSH URLs (git@github.com:user/repo) to HTTPS format
    # For ssh: converts HTTPS URLs to SSH format (git@github.com:user/repo.git)
    # Strips/adds .git extensions as appropriate.
    local commit="$1"
    local remote_url
    remote_url=$(git remote get-url "$REMOTE")
    
    if [[ "$URL_FORMAT" == "ssh" ]]; then
      # Convert HTTPS to SSH if needed
      if [[ "$remote_url" =~ ^https://([^/]+)/(.+)$ ]]; then
        local host="${BASH_REMATCH[1]}"
        local path="${BASH_REMATCH[2]}"
        # Strip .git if present, we'll add it back
        path="${path%.git}"
        echo "git@${host}:${path}.git#${commit}"
      elif [[ "$remote_url" =~ ^git@([^:]+):(.+)$ ]]; then
        # Already SSH format
        local path="${BASH_REMATCH[2]}"
        path="${path%.git}"
        echo "${remote_url%.git}.git#${commit}"
      else
        # Fallback
        echo "${remote_url}#${commit}"
      fi
    else
      # Convert to HTTPS (default)
      remote_url="${remote_url%.git}"
      if [[ "$remote_url" =~ ^git@([^:]+):(.+)$ ]]; then
        remote_url="https://${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
      fi
      echo "${remote_url}/commit/${commit}"
    fi
  }

  # ============================================================================
  # Main Flow
  # ============================================================================

  get_repo_context

  max_tries=3
  try=1
  while (( try <= max_tries )); do
    PREV_SNAPSHOT=$(fetch_previous_snapshot_oid)
    TREE_ID=$(build_snapshot_tree)
    NEW_COMMIT=$(create_snapshot_commit "$TREE_ID" "$PREV_SNAPSHOT")

    # Push first; if rejected or network/auth fails, do not advance local.
    if push_snapshot; then
      # Now move local ref with CAS versus current local tip.
      if update_local_ref "$NEW_COMMIT" "$PREV_SNAPSHOT"; then
        COMMIT_URL=$(build_commit_url "$NEW_COMMIT")

        if [[ "$QUIET" == "false" ]]; then
          echo "âœ… Snapshot pushed!"
          echo "   Branch: ${SNAPSHOT_BRANCH}"
          echo "   Commit: ${NEW_COMMIT}"
          echo "   Remote: ${REMOTE}"
          echo "   URL: ${COMMIT_URL}"
        fi
        echo "$COMMIT_URL"
        exit 0
      else
        echo "âš ï¸  Local snapshot ref moved; retrying ($try/$max_tries)..." >&2
      fi
    else
      echo "âš ï¸  Push rejected/failed; will refetch and retry ($try/$max_tries)..." >&2
    fi

    # brief jitter to de-sync racers
    sleep 0.$(( (RANDOM % 7) + 3 ))
    (( try++ ))
  done

  echo "âŒ Gave up after $max_tries attempts; snapshot branch kept moving or push kept failing." >&2
  exit 1
); }

